<!DOCTYPE html>
<html lang="es" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Voicebot - Call Center Analytics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-tertiary: #94a3b8;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 30px rgba(0,0,0,0.15);
            --shadow-xl: 0 20px 60px rgba(0,0,0,0.2);
            --accent-primary: #667eea;
            --accent-secondary: #764ba2;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
        }

        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-gradient-start: #4c1d95;
            --bg-gradient-end: #5b21b6;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --border-color: #334155;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.3);
            --shadow-lg: 0 10px 30px rgba(0,0,0,0.4);
            --shadow-xl: 0 20px 60px rgba(0,0,0,0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.4s ease;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3), transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(138, 43, 226, 0.3), transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: backgroundPulse 15s ease-in-out infinite;
        }

        @keyframes backgroundPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .header {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-xl);
            position: relative;
            overflow: hidden;
            animation: slideDown 0.6s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header-left h1 {
            color: var(--text-primary);
            font-size: 2.8em;
            margin-bottom: 12px;
            font-weight: 800;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .header-left p {
            color: var(--text-secondary);
            font-size: 1.2em;
            font-weight: 500;
        }

        .header-right {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn i {
            font-size: 18px;
        }

        .theme-toggle {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            padding: 14px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .theme-toggle:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .last-update {
            color: var(--text-tertiary);
            font-size: 0.95em;
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .kpi-card {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-lg);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .kpi-card:hover::before {
            transform: scaleX(1);
        }

        .kpi-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-xl);
        }

        .kpi-icon {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .kpi-label {
            color: var(--text-secondary);
            font-size: 0.95em;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .kpi-value {
            font-size: 3em;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 8px;
            line-height: 1;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .kpi-subtitle {
            color: var(--text-tertiary);
            font-size: 0.9em;
            font-weight: 500;
        }

        .kpi-trend {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 6px 14px;
            border-radius: 25px;
            font-size: 0.85em;
            font-weight: 700;
            margin-top: 12px;
        }

        .trend-positive {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
        }

        .trend-neutral {
            background: rgba(59, 130, 246, 0.15);
            color: var(--info);
        }

        .trend-negative {
            background: rgba(239, 68, 68, 0.15);
            color: var(--danger);
        }

        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(550px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .chart-card {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-lg);
            transition: all 0.3s ease;
            animation: fadeIn 1s ease-out 0.4s both;
        }

        .chart-card:hover {
            box-shadow: var(--shadow-xl);
            transform: translateY(-5px);
        }

        .chart-card h3 {
            color: var(--text-primary);
            margin-bottom: 25px;
            font-size: 1.4em;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chart-card h3 i {
            color: var(--accent-primary);
            font-size: 1.2em;
        }

        .chart-container {
            position: relative;
            height: 320px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .table-container {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            box-shadow: var(--shadow-lg);
            overflow-x: auto;
            animation: fadeIn 1.2s ease-out 0.6s both;
        }

        .table-container h3 {
            color: var(--text-primary);
            margin-bottom: 25px;
            font-size: 1.4em;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            padding: 18px 20px;
            text-align: left;
            font-weight: 700;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        th:first-child {
            border-radius: 12px 0 0 0;
        }

        th:last-child {
            border-radius: 0 12px 0 0;
        }

        td {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-weight: 500;
        }

        tbody tr {
            transition: all 0.2s ease;
        }

        tbody tr:hover {
            background: var(--bg-primary);
            transform: scale(1.01);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 25px;
            font-size: 0.85em;
            font-weight: 700;
        }

        .status-contacted {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
        }

        .status-not-contacted {
            background: rgba(239, 68, 68, 0.15);
            color: var(--danger);
        }

        .loading {
            text-align: center;
            padding: 80px 20px;
            color: white;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.3em;
            font-weight: 600;
        }

        
        .loading-card {
            max-width: 520px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 18px;
            padding: 26px 22px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 60px rgba(0,0,0,0.25);
        }

        .loading-subtext {
            margin-top: 8px;
            font-size: 0.98em;
            opacity: 0.9;
        }

        .progress-wrap {
            margin-top: 18px;
            height: 10px;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 999px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 999px;
            transition: width 200ms ease;
        }

        .loading-meta {
            margin-top: 12px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 0.92em;
            opacity: 0.95;
        }

        .loading-meta span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .loading-detail {
            opacity: 0.85;
        }
.error {
            background: rgba(239, 68, 68, 0.15);
            border: 2px solid var(--danger);
            color: var(--danger);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .error i {
            font-size: 24px;
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }

            .header-right {
                width: 100%;
                flex-direction: column;
            }

            .btn, .theme-toggle {
                width: 100%;
                justify-content: center;
            }

            .chart-grid {
                grid-template-columns: 1fr;
            }
            
            .kpi-grid {
                grid-template-columns: 1fr;
            }

            .header-left h1 {
                font-size: 2em;
            }

            .kpi-value {
                font-size: 2.5em;
            }
        }

        .stats-summary {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-lg);
            animation: fadeIn 1s ease-out 0.3s both;
        }

        .stats-summary h3 {
            color: var(--text-primary);
            margin-bottom: 20px;
            font-size: 1.4em;
            font-weight: 700;
        }

        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            padding: 15px;
            background: var(--bg-primary);
            border-radius: 12px;
            border-left: 4px solid var(--accent-primary);
        }

        .stat-item-label {
            color: var(--text-tertiary);
            font-size: 0.85em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .stat-item-value {
            color: var(--text-primary);
            font-size: 1.5em;
            font-weight: 700;
        }
    
        .filter-bar{
            display:flex;
            flex-wrap:wrap;
            gap:12px;
            align-items:flex-end;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 14px 16px;
            box-shadow: var(--shadow-sm);
            margin: 14px 0 18px;
        }
        .filter-group{
            display:flex;
            flex-direction:column;
            gap:6px;
            min-width: 170px;
        }
        .filter-group label{
            font-size: .85em;
            color: var(--text-secondary);
            font-weight: 600;
        }
        .filter-group select,
        .filter-group input[type="date"]{
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-primary);
            color: var(--text-primary);
            outline:none;
        }
        .filter-actions{
            display:flex;
            gap:10px;
            align-items:center;
            margin-left:auto;
        }
        .btn-sm{ padding: 10px 12px; }
        .btn-ghost{
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        .btn-secondary{
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
        }

        .compare-panel{
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 18px;
            padding: 16px;
            box-shadow: var(--shadow-md);
            margin-bottom: 18px;
        }
        .compare-header{
            display:flex;
            justify-content:space-between;
            align-items:center;
            margin-bottom: 12px;
        }
        .compare-grid{
            display:grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 12px;
            margin-bottom: 14px;
        }
        .compare-card{
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 12px 14px;
            background: var(--bg-primary);
        }
        .compare-card h4{
            margin-bottom: 10px;
            color: var(--text-primary);
        }
        .compare-row{
            display:grid;
            grid-template-columns: 60px 1fr 60px 1fr;
            gap: 8px;
            align-items:center;
        }
        .compare-row label{ color: var(--text-secondary); font-size: .85em; font-weight:600; }
        .compare-row input{
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        .compare-actions{
            display:flex;
            flex-direction:column;
            justify-content:center;
            gap: 10px;
        }
        .small-note{ color: var(--text-tertiary); font-size: .85em; }

        .badge{
            display:inline-block;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: .8em;
            font-weight: 700;
            border: 1px solid var(--border-color);
        }
        .badge-success{ background: rgba(16,185,129,.15); color: var(--success); }
        .badge-warning{ background: rgba(245,158,11,.15); color: var(--warning); }
        .badge-danger{ background: rgba(239,68,68,.15); color: var(--danger); }
</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-left">
                    <h1><i class="fas fa-phone-volume"></i> Dashboard Voicebot</h1>
                    <p>Análisis en tiempo real de campañas de llamadas automatizadas</p>
                    <div class="last-update" id="lastUpdate">
                        <span class="pulse-dot"></span>
                        <span id="updateText">Iniciando...</span>
                    </div>
                </div>
                <div class="header-right">
                    <button class="btn" onclick="loadData({ forceNetwork: true, cacheFirst: false, reason: \'manual\' })" id="refreshBtn">
                        <i class="fas fa-sync-alt"></i>
                        <span>Actualizar Datos</span>
                    </button>
                    <button class="theme-toggle" onclick="toggleTheme()" id="themeBtn">
                        <i class="fas fa-moon"></i>
                    </button>
                </div>
            
        <div class="filter-bar">
            <div class="filter-group">
                <label><i class="fas fa-filter"></i> Rango rápido</label>
                <select id="quickRange">
                    <option value="all">Todo</option>
                    <option value="today">Hoy</option>
                    <option value="yesterday">Ayer</option>
                    <option value="last7">Últimos 7 días</option>
                    <option value="last30">Últimos 30 días</option>
                    <option value="thisMonth">Este mes</option>
                    <option value="lastMonth">Mes pasado</option>
                    <option value="lastWeek">Semana pasada</option>
                </select>
            </div>

            <div class="filter-group">
                <label><i class="fas fa-calendar"></i> Desde</label>
                <input type="date" id="dateFrom">
            </div>
            <div class="filter-group">
                <label><i class="fas fa-calendar"></i> Hasta</label>
                <input type="date" id="dateTo">
            </div>

            <div class="filter-actions">
                <button class="btn btn-sm" id="applyFilterBtn">
                    <i class="fas fa-check"></i> Aplicar
                </button>
                <button class="btn btn-sm btn-ghost" id="clearFilterBtn">
                    <i class="fas fa-eraser"></i> Limpiar
                </button>
            </div>

            <div class="filter-actions">
                <button class="btn btn-sm btn-secondary" id="openCompareBtn">
                    <i class="fas fa-columns"></i> Comparativa
                </button>
            </div>
        </div>

        <div class="compare-panel" id="comparePanel" style="display:none;">
            <div class="compare-header">
                <h3><i class="fas fa-columns"></i> Comparativa entre rangos</h3>
                <button class="btn btn-sm btn-ghost" id="closeCompareBtn"><i class="fas fa-times"></i></button>
            </div>
            <div class="compare-grid">
                <div class="compare-card">
                    <h4>Rango A</h4>
                    <div class="compare-row">
                        <label>Desde</label><input type="date" id="cmpAFrom">
                        <label>Hasta</label><input type="date" id="cmpATo">
                    </div>
                </div>
                <div class="compare-card">
                    <h4>Rango B</h4>
                    <div class="compare-row">
                        <label>Desde</label><input type="date" id="cmpBFrom">
                        <label>Hasta</label><input type="date" id="cmpBTo">
                    </div>
                </div>
                <div class="compare-card compare-actions">
                    <button class="btn" id="runCompareBtn"><i class="fas fa-play"></i> Comparar</button>
                    <div class="small-note">Compara KPIs y muestra variación (Δ).</div>
                </div>
            </div>

            <div class="compare-results" id="compareResults" style="display:none;">
                <div class="chart-card full-width">
                    <h3><i class="fas fa-chart-bar"></i> Comparativa de KPIs</h3>
                    <div class="chart-container">
                        <canvas id="compareChart"></canvas>
                    </div>
                </div>
                <div class="table-container">
                    <h3><i class="fas fa-table"></i> Detalle comparativo</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>KPI</th>
                                <th>Rango A</th>
                                <th>Rango B</th>
                                <th>Δ (B - A)</th>
                                <th>Δ %</th>
                            </tr>
                        </thead>
                        <tbody id="compareTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
</div>
        </div>

        <div id="loading" class="loading">
            <div class="loading-card">
                <div class="loading-spinner"></div>
                <div class="loading-text" id="loadingText">Cargando datos...</div>
                <div class="loading-subtext" id="loadingStage">Iniciando…</div>
                <div class="progress-wrap">
                    <div class="progress-bar" id="loadingBar"></div>
                </div>
                <div class="loading-meta">
                    <span><i class="fas fa-tachometer-alt"></i> <strong id="loadingPct">0%</strong></span>
                    <span><i class="fas fa-stopwatch"></i> <strong id="loadingElapsed">0s</strong></span>
                    <span class="loading-detail" id="loadingDetail"></span>
                </div>
            </div>
        </div>

        <div id="error" style="display: none;"></div>

        <div id="dashboard" style="display: none;">
            <!-- KPIs Principales -->
            <div class="kpi-grid">
                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-phone-alt"></i>
                    </div>
                    <div class="kpi-label">Total Llamadas</div>
                    <div class="kpi-value" id="totalCalls">0</div>
                    <div class="kpi-subtitle">Todas las campañas</div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-calendar-day"></i>
                    </div>
                    <div class="kpi-label">Llamadas Hoy</div>
                    <div class="kpi-value" id="callsToday">0</div>
                    <div class="kpi-subtitle" id="todayDate"></div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-users"></i>
                    </div>
                    <div class="kpi-label">Clientes Únicos</div>
                    <div class="kpi-value" id="uniqueLeads">0</div>
                    <div class="kpi-subtitle">Contactos diferentes</div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-check-circle"></i>
                    </div>
                    <div class="kpi-label">Contactados</div>
                    <div class="kpi-value" id="contacted">0</div>
                    <div class="kpi-subtitle" id="contactedPercent"></div>
                    <span class="kpi-trend trend-positive" id="contactedTrend"></span>
                </div>

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-times-circle"></i>
                    </div>
                    <div class="kpi-label">No Contactados (3)</div>
                    <div class="kpi-value" id="notContacted">0</div>
                    <div class="kpi-subtitle" id="notContactedPercent"></div>
                    <div class="kpi-subtitle" style="margin-top:6px;color:var(--text-tertiary);">(ANSWERMACHINE_AUTO, FAILED_AUTO, CANCEL_AUTO)</div>
                </div>

                

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-exclamation-triangle"></i>
                    </div>
                    <div class="kpi-label">Fallas Servidor IA</div>
                    <div class="kpi-value" id="aiServerFails">0</div>
                    <div class="kpi-subtitle" id="aiServerFailsPercent"></div>
                    <div class="kpi-subtitle" style="margin-top:6px;color:var(--text-tertiary);">(AI_SERVER_START_FAILED)</div>
                </div>

<div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-redo"></i>
                    </div>
                    <div class="kpi-label">Intentos Promedio</div>
                    <div class="kpi-value" id="avgAttempts">0</div>
                    <div class="kpi-subtitle">Para contactar</div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-clock"></i>
                    </div>
                    <div class="kpi-label">Duración Promedio</div>
                    <div class="kpi-value" id="avgDuration">0</div>
                    <div class="kpi-subtitle">Segundos por llamada</div>
                </div>

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-chart-line"></i>
                    </div>
                    <div class="kpi-label">Tasa de Contestación</div>
                    <div class="kpi-value" id="successRate">0%</div>
                    <div class="kpi-subtitle">ANSWERED / Total (contestadas)</div>
                    <span class="kpi-trend trend-neutral" id="successTrend"></span>
                </div>

                <div class="kpi-card">
                    <div class="kpi-icon">
                        <i class="fas fa-handshake"></i>
                    </div>
                    <div class="kpi-label">Efectividad / Compromisos de Pago</div>
                    <div class="kpi-value" id="paymentCommitments">0</div>
                    <div class="kpi-subtitle" id="paymentCommitmentsPercent">0%</div>
                    <div class="kpi-subtitle" style="margin-top:6px;color:var(--text-tertiary);">(confirma, compromiso_de_pago)</div>
                </div>
            </div>

            <!-- Resumen Estadístico -->
            <div class="stats-summary">
                <h3><i class="fas fa-chart-bar"></i> Resumen Estadístico</h3>
                <div class="stats-row">
                    <div class="stat-item">
                        <div class="stat-item-label">Duración Total</div>
                        <div class="stat-item-value" id="totalDuration">0h 0m</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-item-label">Duración Máxima</div>
                        <div class="stat-item-value" id="maxDuration">0s</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-item-label">Tasa de Respuesta</div>
                        <div class="stat-item-value" id="answerRate">0%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-item-label">Llamadas/Cliente</div>
                        <div class="stat-item-value" id="callsPerLead">0</div>
                    </div>
                </div>
            </div>

            <!-- Gráficos -->
            <div class="chart-grid">
                <div class="chart-card">
                    <h3><i class="fas fa-calendar-alt"></i> Llamadas por Mes</h3>
                    <div class="chart-container">
                        <canvas id="monthlyChart"></canvas>
                    </div>
                </div>

                <div class="chart-card">
                    <h3><i class="fas fa-tasks"></i> Estado de Llamadas</h3>
                    <div class="chart-container">
                        <canvas id="dispositionChart"></canvas>
                    </div>
                </div>

                <div class="chart-card">
                    <h3><i class="fas fa-user-check"></i> Contactados vs No Contactados</h3>
                    <div class="chart-container">
                        <canvas id="contactChart"></canvas>
                    </div>
                </div>

                <div class="chart-card">
                    <h3><i class="fas fa-list-alt"></i> Tipificaciones Detalladas</h3>
                    <div class="chart-container">
                        <canvas id="detailedDispositionChart"></canvas>
                    </div>
                </div>

                <div class="chart-card full-width">
                    <h3><i class="fas fa-hourglass-half"></i> Distribución de Duración de Llamadas</h3>
                    <div class="chart-container">
                        <canvas id="durationChart"></canvas>
                    </div>
                </div>

                <div class="chart-card full-width">
                    <h3><i class="fas fa-phone-square-alt"></i> Distribución de Intentos de Llamada</h3>
                    <div class="chart-container">
                        <canvas id="attemptsChart"></canvas>
                    </div>
                </div>
            </div>

            

            <div class="table-container">
                <h3><i class="fas fa-list"></i> Tipificaciones encontradas (todas)</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tipificación</th>
                            <th>Conteo</th>
                            <th>%</th>
                            <th>Clasificación</th>
                        </tr>
                    </thead>
                    <tbody id="allDispositionsBody"></tbody>
                </table>
                <div class="small-note" style="margin-top:10px;">
                    Nota: <strong>No contactado</strong> = (ANSWERMACHINE_AUTO, FAILED_AUTO, CANCEL_AUTO). <strong>Falla IA</strong> = AI_SERVER_START_FAILED.
                </div>
            </div>

</div>
        </div>
    </div>

    <script>
        // Acceso a Google Sheets (con fallback de proxies)
        const SHEET_ID = '1cqownC49nCa-ZEJpnZR_cRk63r005kaNFzQ8OOAv9EQ';
        const SHEET_GID = '0';
        // Timeouts de red (ms)
        const FETCH_TIMEOUT_MS = 45000;

        const SHEET_DIRECT_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${SHEET_GID}`;

        // 1) Intentamos directo (puede fallar por CORS), 2) usamos proxy(s).
        const PROXY_BUILDERS = [
            // Alternativas (más de una, por si alguna se cae)
            (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
            (url) => `https://thingproxy.freeboard.io/fetch/${url}`,
            (url) => `https://cors.isomorphic-git.org/${url}`,
            (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
        ];
let allData = [];

        // -----------------------------
        // Mapeo de columnas (para coincidir con Excel / tabla dinámica)
        // Priorizamos lead_current_disposition para tipificaciones y contactados.
        // -----------------------------
        let COLMAP = null;
        let COL_DISP_CURRENT = null; // lead_current_disposition
        let COL_DISP_CALL = null;    // call_disposition (tasa contestadas)

        function initColumnMap(sampleRow) {
            if (!sampleRow) return;
            // Si cambia el esquema (muy raro), rearmamos el mapa
            const keys = Object.keys(sampleRow);
            if (!COLMAP || keys.length !== Object.keys(COLMAP).length) {
                COLMAP = {};
                keys.forEach(k => {
                    COLMAP[String(k).trim().toLowerCase()] = k;
                });
                COL_DISP_CURRENT = COLMAP['lead_current_disposition'] || null;
                COL_DISP_CALL = COLMAP['call_disposition'] || null;
            }
        }

        function getCurrentDisposition(row) {
            if (!row) return '';
            if (COL_DISP_CURRENT && row[COL_DISP_CURRENT] !== undefined) return row[COL_DISP_CURRENT];
            // fallback por si el CSV trae el nombre exacto
            return row.lead_current_disposition ?? '';
        }

        function dispositionLabelFromCurrent(row) {
            const raw = getCurrentDisposition(row);
            const key = normCurrentKey(raw);
            if (!key) return 'Sin clasificar';
            if (key === 'NO_ES_TITULAR') return 'no_es_titular (agrupado)';
            return key; // ya va normalizado (UPPER)
        }

        function getCallDisposition(row) {
            if (!row) return '';
            if (COL_DISP_CALL && row[COL_DISP_CALL] !== undefined) return row[COL_DISP_CALL];
            return row.call_disposition ?? '';
        }


        // -----------------------------
        // Tipificaciones / Reglas de Contacto
        // -----------------------------
        const NON_CONTACT_DISPOSITIONS = new Set([
            'ANSWERMACHINE_AUTO',
            'ANSWER_MACHINE',
            'ANSWER_MACHINE_AUTO',
            'FAILED_AUTO',
            'CANCEL_AUTO'
        ]);

        const AI_SERVER_FAIL_DISPOSITIONS = new Set([
            'AI_SERVER_START_FAILED'
        ]);

        // Tipificaciones que INDICAN que el cliente respondió al bot (según tu definición)
        // Nota: se comparan normalizadas (trim + upper)
        const RESPONDED_DISPOSITIONS = new Set([
            'UNDEFINED',
            'CONFIRMA',
            'COMPROMISO_DE_PAGO',
            'ANSWER'
        ]);

        function normDisp(v) {
            return String(v || '').trim().toUpperCase();
        }

        // Normaliza específicamente la lead_current_disposition para AGRUPAR variantes:
        // - cualquier cosa que empiece con NO_ES o NO_ES_TITULAR => NO_ES_TITULAR
        function normCurrentKey(v) {
            const u = normDisp(v);
            if (!u) return '';
            if (u.startsWith('NO_ES_TITULAR') || u.startsWith('NO_ES')) return 'NO_ES_TITULAR';
            return u;
        }

        function escapeHtml(str) {
            return String(str ?? '')
                .replaceAll('&', '&amp;')
                .replaceAll('<', '&lt;')
                .replaceAll('>', '&gt;')
                .replaceAll('"', '&quot;')
                .replaceAll("'", '&#39;');
        }

        function isNonContactDisposition(d) {
            return NON_CONTACT_DISPOSITIONS.has(normDisp(d));
        }

        function isAiServerFailDisposition(d) {
            return AI_SERVER_FAIL_DISPOSITIONS.has(normDisp(d));
        }

        // Clasificación según tus reglas (basado en lead_current_disposition):
        // - NO CONTACTADOS (3): ANSWERMACHINE_AUTO, FAILED_AUTO, CANCEL_AUTO
        // - FALLAS SERVIDOR IA: AI_SERVER_START_FAILED
        // - RESPONDIÓ: (lista indicada por ti)
        // - OTROS: cualquier otra tipificación (para que la veas y luego decidimos qué hacer con ellas)
        function isRespondedDisposition(d) {
            const u = normDisp(d);
            // Agrupado: cualquier NO_ES* cuenta como respondió (el bot sí interactuó)
            if (u.startsWith('NO_ES_TITULAR') || u.startsWith('NO_ES')) return true;
            return RESPONDED_DISPOSITIONS.has(u);
        }

        function isContacted(d) {
            // “Contactado” = el cliente RESPONDIÓ (según tu lista)
            return isRespondedDisposition(d);
        }

        function classifyDisposition(d) {
            const nd = normDisp(d);
            if (!nd) return 'OTROS (SIN TIPIFICACIÓN)';
            if (isAiServerFailDisposition(nd)) return 'FALLA SERVIDOR IA';
            if (isNonContactDisposition(nd)) return 'NO CONTACTADO (3)';
            if (isRespondedDisposition(nd)) return 'RESPONDIÓ';
            return 'OTROS';
        }

        // -----------------------------
        // Filtros de fecha (estado)
        // -----------------------------
        let filterState = {
            quick: 'all',
            from: null, // YYYY-MM-DD
            to: null    // YYYY-MM-DD
        };

        function parseRowDateKey(row) {
            // date_start suele venir ISO: 2025-12-15T15:38:27...
            const raw = row?.date_start || row?.date_end || '';
            if (!raw) return null;
            const key = String(raw).split('T')[0];
            return key || null;
        }

        function inRange(dateKey, fromKey, toKey) {
            if (!dateKey) return false;
            if (fromKey && dateKey < fromKey) return false;
            if (toKey && dateKey > toKey) return false;
            return true;
        }

        function computeQuickRange(quick) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            const fmt = (d) => d.toISOString().split('T')[0];

            if (quick === 'today') {
                const k = fmt(today);
                return { from: k, to: k };
            }
            if (quick === 'yesterday') {
                const d = new Date(today);
                d.setDate(d.getDate() - 1);
                const k = fmt(d);
                return { from: k, to: k };
            }
            if (quick === 'last7') {
                const from = new Date(today);
                from.setDate(from.getDate() - 6);
                return { from: fmt(from), to: fmt(today) };
            }
            if (quick === 'last30') {
                const from = new Date(today);
                from.setDate(from.getDate() - 29);
                return { from: fmt(from), to: fmt(today) };
            }
            if (quick === 'thisMonth') {
                const from = new Date(today.getFullYear(), today.getMonth(), 1);
                const to = new Date(today.getFullYear(), today.getMonth() + 1, 0);
                return { from: fmt(from), to: fmt(to) };
            }
            if (quick === 'lastMonth') {
                const from = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                const to = new Date(today.getFullYear(), today.getMonth(), 0);
                return { from: fmt(from), to: fmt(to) };
            }
            if (quick === 'lastWeek') {
                // Semana pasada (Lun-Dom) basada en semana ISO simplificada:
                const day = (today.getDay() + 6) % 7; // lunes=0
                const thisMon = new Date(today);
                thisMon.setDate(thisMon.getDate() - day);
                const lastMon = new Date(thisMon);
                lastMon.setDate(lastMon.getDate() - 7);
                const lastSun = new Date(thisMon);
                lastSun.setDate(lastSun.getDate() - 1);
                return { from: fmt(lastMon), to: fmt(lastSun) };
            }
            return { from: null, to: null };
        }

        function getViewData() {
            const fromKey = filterState.from;
            const toKey = filterState.to;
            if (!fromKey && !toKey) return allData;

            return allData.filter(r => {
                const k = parseRowDateKey(r);
                return inRange(k, fromKey, toKey);
            });
        }

        function setFilterInputs(fromKey, toKey) {
            const elFrom = document.getElementById('dateFrom');
            const elTo = document.getElementById('dateTo');
            if (elFrom) elFrom.value = fromKey || '';
            if (elTo) elTo.value = toKey || '';
        }


        let charts = {};
        let currentViewData = [];



        // -----------------------------
        // DEBUG / LOGS + LOADING UI
        // -----------------------------
        const DEBUG = true;

        function debugLog(...args) { if (DEBUG) console.log(...args); }
        function debugWarn(...args) { if (DEBUG) console.warn(...args); }
        function debugError(title, err) {
            console.error(title);
            console.error(err);
        }
        function debugGroup(title, fn) {
            if (!DEBUG) return fn();
            console.groupCollapsed(title);
            try { fn(); } finally { console.groupEnd(); }
        }

        // Helper seguro para setear texto sin romper si falta el elemento
        function setText(id, value) {
            const el = document.getElementById(id);
            if (!el) { debugWarn(`[dom] falta #${id}`); return; }
            el.textContent = String(value ?? '');
        }

        // Capturar errores globales para verlos en consola
        window.addEventListener('error', (e) => {
            debugError('[window.error]', e.error || e.message);
        });
        window.addEventListener('unhandledrejection', (e) => {
            debugError('[unhandledrejection]', e.reason);
        });

        function showLoadingUI(show) {
            const el = document.getElementById('loading');
            if (el) el.style.display = show ? 'block' : 'none';
        }
        function showDashboardUI(show) {
            const el = document.getElementById('dashboard');
            if (el) el.style.display = show ? 'block' : 'none';
        }
        function showErrorUI(show) {
            const el = document.getElementById('error');
            if (el) el.style.display = show ? 'block' : 'none';
        }

        function setLoadingState({ pct, stage, detail }) {
            const bar = document.getElementById('loadingBar');
            const pctEl = document.getElementById('loadingPct');
            const stageEl = document.getElementById('loadingStage');
            const detailEl = document.getElementById('loadingDetail');

            const safePct = Math.max(0, Math.min(100, pct ?? 0));
            if (bar) bar.style.width = `${safePct}%`;
            if (pctEl) pctEl.textContent = `${safePct}%`;
            if (stageEl) stageEl.textContent = stage || '';
            if (detailEl) detailEl.textContent = detail || '';

            debugLog(`[loading] ${safePct}% | ${stage || ''} ${detail ? '— ' + detail : ''}`);
        }

        // Compat helper: some code paths call updateLoadingProgress(...)
        function updateLoadingProgress(pct, stage, detail = '') {
            setLoadingState({ pct, stage, detail });
        }

        function startElapsedTimer() {
            const start = performance.now();
            const el = document.getElementById('loadingElapsed');
            const id = setInterval(() => {
                const sec = Math.floor((performance.now() - start) / 1000);
                if (el) el.textContent = `${sec}s`;
            }, 250);
            return () => clearInterval(id);
        }

        function startProgressRamp(fromPct, toPct, stageLabel) {
            let pct = fromPct;
            const id = setInterval(() => {
                // Avanza lento y se “atasca” cerca del final (para que el % sea realista)
                const remaining = toPct - pct;
                if (remaining <= 0) return;
                const step = Math.max(1, Math.round(remaining * 0.08));
                pct = Math.min(toPct, pct + step);
                setLoadingState({ pct, stage: stageLabel, detail: '' });
            }, 350);
            return () => clearInterval(id);
        }

        function updateLastUpdateLabel(prefix) {
            const now = new Date();
            const txt = `${prefix} • ${now.toLocaleString('es-HN', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            })}`;
            setText('updateText', `Última actualización: ${txt}`);
        }

        // -----------------------------
        // CACHE (IndexedDB)
        // -----------------------------
        const CACHE_DB = 'voicebot_dashboard_cache_v2';
        const CACHE_STORE = 'kv';
        const CACHE_KEY = `sheet_${SHEET_ID}_gid_${SHEET_GID}`;

        function openCacheDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(CACHE_DB, 1);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains(CACHE_STORE)) {
                        db.createObjectStore(CACHE_STORE);
                    }
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function cacheGet() {
            try {
                const db = await openCacheDB();
                return await new Promise((resolve, reject) => {
                    const tx = db.transaction(CACHE_STORE, 'readonly');
                    const st = tx.objectStore(CACHE_STORE);
                    const req = st.get(CACHE_KEY);
                    req.onsuccess = () => resolve(req.result || null);
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                debugWarn('[cacheGet] no disponible', e);
                return null;
            }
        }

        async function cacheSet(value) {
            try {
                const db = await openCacheDB();
                await new Promise((resolve, reject) => {
                    const tx = db.transaction(CACHE_STORE, 'readwrite');
                    const st = tx.objectStore(CACHE_STORE);
                    const req = st.put(value, CACHE_KEY);
                    req.onsuccess = () => resolve(true);
                    req.onerror = () => reject(req.error);
                });
            } catch (e) {
                debugWarn('[cacheSet] no se pudo guardar', e);
            }
        }

        // -----------------------------
        // FETCH + PARSE HELPERS
        // -----------------------------
        async function fetchWithTimeout(url, { signal, timeoutMs = 45000, forceNoStore = false } = {}) {
            const ctrl = new AbortController();
            const timer = setTimeout(() => ctrl.abort(new Error('Timeout')), timeoutMs);

            if (signal) {
                if (signal.aborted) ctrl.abort();
                else signal.addEventListener('abort', () => ctrl.abort(), { once: true });
            }

            try {
                return await fetch(url, {
                    signal: ctrl.signal,
                    cache: forceNoStore ? 'no-store' : 'default'
                });
            } finally {
                clearTimeout(timer);
            }
        }

        async function fetchCsvTextWithFallback({ signal, forceNoStore = false } = {}) {
            // Si abres el HTML con doble click (file://) el navegador te pone origin "null"
            // y CORS se vuelve muchísimo más estricto. Mejor usar Live Server / http://localhost.
            if (location.protocol === 'file:') {
                throw new Error('CORS: Estás abriendo el archivo con file:// (origin "null"). Abre el dashboard con Live Server (http://localhost) o súbelo a un hosting para poder leer Google Sheets.');
            }

            // Intento 0: endpoint alterno de Google (GViz) que a veces funciona mejor que /export
            const gvizUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&gid=${SHEET_GID}`;

            const urls = [
                gvizUrl,
                SHEET_DIRECT_URL,
                ...PROXY_BUILDERS.map(fn => fn(gvizUrl)),
                ...PROXY_BUILDERS.map(fn => fn(SHEET_DIRECT_URL)),
            ];

            let lastErr = null;

            for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                try {
                    debugLog(`[net] intentando (${i + 1}/${urls.length}): ${url}`);
                    updateLoadingProgress(10 + Math.min(40, Math.round((i / Math.max(1, urls.length - 1)) * 40)), 'Descargando CSV...');
                    const resp = await fetchWithTimeout(url, {
                        signal,
                        timeoutMs: FETCH_TIMEOUT_MS,
                        forceNoStore
                    });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
                    const txt = await resp.text();
                    // Sanity check rápido (evita guardar páginas HTML por error)
                    if (!txt || txt.length < 10) throw new Error('Respuesta vacía');
                    if (txt.trim().startsWith('<!doctype') || txt.trim().startsWith('<html')) throw new Error('Respuesta parece HTML (no CSV). Revisa si la hoja es pública.');
                    return { csvText: txt, usedUrl: url };
                } catch (err) {
                    lastErr = err;
                    debugWarn(`[net] falló: ${url}`, err);
                }
            }

            throw lastErr ?? new Error('No se pudo descargar el CSV');
        }

async function hashText(text) {
            try {
                const enc = new TextEncoder();
                const buf = await crypto.subtle.digest('SHA-256', enc.encode(text));
                return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (e) {
                // Fallback “rápido” si WebCrypto no está disponible (poco probable en Chrome)
                debugWarn('[hashText] WebCrypto no disponible, usando fallback');
                let h = 0;
                for (let i = 0; i < text.length; i++) h = (h * 31 + text.charCodeAt(i)) >>> 0;
                return String(h);
            }
        }

        function pickRow(r) {
            // Guardamos solo campos usados por el dashboard (menos memoria + caché más liviana)
            // IMPORTANTE: incluimos lead_current_disposition porque es la base de las tipificaciones del reporte
            return {
                date_start: r.date_start || null,
                call_disposition: r.call_disposition || null,
                lead_current_disposition: (r.lead_current_disposition !== undefined ? r.lead_current_disposition : (r['lead_current_disposition'] ?? null)),
                lead_first_name: r.lead_first_name || null,
                lead_called_count: r.lead_called_count || 0,
                total_duration: r.total_duration || 0,
                answer_duration: r.answer_duration || 0,
                lead_last_phone_dialed: r.lead_last_phone_dialed || null
            };
        }

        function parseCsvToRows(csvText) {
            return new Promise((resolve, reject) => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    worker: true,
                    complete: function(results) {
                        try {
                            const rows = (results.data || [])
                                .filter(r => r && r.date_start)
                                .map(pickRow);
                            resolve(rows);
                        } catch (e) {
                            reject(e);
                        }
                    },
                    error: function(error) {
                        reject(error);
                    }
                });
            });
        }
        // Definir tipificaciones de contactados
        // Contactados: ver reglas al inicio (NON_CONTACT_DISPOSITIONS / AI_SERVER_FAIL_DISPOSITIONS)

        // Tema
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            
            const btn = document.getElementById('themeBtn');
            btn.innerHTML = newTheme === 'light' 
                ? '<i class="fas fa-moon"></i>' 
                : '<i class="fas fa-sun"></i>';
            
            localStorage.setItem('theme', newTheme);
            
            // Actualizar gráficos con el nuevo tema
            updateChartsTheme();
        }

        // Cargar tema guardado
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            const btn = document.getElementById('themeBtn');
            btn.innerHTML = savedTheme === 'light' 
                ? '<i class="fas fa-moon"></i>' 
                : '<i class="fas fa-sun"></i>';
        }

        function updateChartsTheme() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = isDark ? '#f1f5f9' : '#1e293b';
            const gridColor = isDark ? '#334155' : '#e2e8f0';

            Object.values(charts).forEach(chart => {
                if (chart && chart.options) {
                    // Actualizar colores de texto
                    if (chart.options.plugins && chart.options.plugins.legend) {
                        chart.options.plugins.legend.labels.color = textColor;
                    }
                    if (chart.options.scales) {
                        if (chart.options.scales.x) {
                            chart.options.scales.x.ticks.color = textColor;
                            chart.options.scales.x.grid.color = gridColor;
                        }
                        if (chart.options.scales.y) {
                            chart.options.scales.y.ticks.color = textColor;
                            chart.options.scales.y.grid.color = gridColor;
                        }
                    }
                    chart.update();
                }
            });
        }

        async function loadData(opts = {}) {
            // ✅ Optimizaciones: caché (IndexedDB), fallback a caché si falla red, y progreso + logs.
            const options = {
                cacheFirst: true,         // usar caché si existe
                backgroundRefresh: false, // si ya pintó desde caché, refrescar en background
                forceNetwork: false,      // forzar fetch (botón)
                reason: 'unknown',
                ...opts
            };

            const btn = document.getElementById('refreshBtn');
            const btnIcon = btn.querySelector('i');

            // Evitar cargas concurrentes
            if (window.__VOICEBOT_LOADING__) {
                debugWarn(`[loadData] ya hay una carga en curso (reason=${window.__VOICEBOT_LOADING_REASON__}). Ignorando (reason=${options.reason}).`);
                return;
            }
            window.__VOICEBOT_LOADING__ = true;
            window.__VOICEBOT_LOADING_REASON__ = options.reason;

            // Abortar request anterior si existiera
            if (window.__VOICEBOT_ABORT__) {
                try { window.__VOICEBOT_ABORT__.abort(); } catch (_) {}
            }
            const abortCtrl = new AbortController();
            window.__VOICEBOT_ABORT__ = abortCtrl;

            btn.disabled = true;
            btnIcon.className = 'fas fa-spinner fa-spin';

            showLoadingUI(true);
            showErrorUI(false);

            const t0 = performance.now();
            const elapsedStop = startElapsedTimer();

            try {
                debugGroup(`[Voicebot] Carga iniciada (reason=${options.reason})`, () => {});
                setLoadingState({ pct: 2, stage: 'Preparando...', detail: '' });

                // 1) Intentar leer caché
                const cached = await cacheGet();
                const cacheUsable = cached && Array.isArray(cached.rows) && cached.rows.length >= 0;

                if (options.cacheFirst && !options.forceNetwork && cacheUsable) {
                    const ageMs = Date.now() - (cached.fetchedAt || 0);
                    const ageMin = Math.round(ageMs / 60000);

                    debugLog(`[cache] hit: ${cached.rows.length.toLocaleString()} filas (edad: ${ageMin} min)`);
                    setLoadingState({ pct: 18, stage: 'Cargando desde caché...', detail: `${cached.rows.length.toLocaleString()} filas` });

                    allData = cached.rows;
                    await processData({ progressFrom: 18, progressTo: 100 });

                    showLoadingUI(false);
                    showDashboardUI(true);
                    updateLastUpdateLabel('Cargado desde caché');

                    // Refresco en background (stale-while-revalidate)
                    if (options.backgroundRefresh) {
                        setTimeout(() => {
                            loadData({ cacheFirst: true, backgroundRefresh: false, forceNetwork: true, reason: 'background' })
                                .catch(() => {});
                        }, 800);
                    }

                    return;
                }

                // 2) Fetch desde red (con fallback de proxies)
                setLoadingState({ pct: 10, stage: 'Descargando CSV...', detail: '' });
                const { csvText, usedUrl } = await fetchCsvTextWithFallback({ signal: abortCtrl.signal, forceNoStore: options.forceNetwork });

                debugLog(`[net] CSV descargado (${(csvText.length/1024/1024).toFixed(2)} MB) vía: ${usedUrl}`);

                setLoadingState({ pct: 28, stage: 'Verificando cambios...', detail: '' });
                const newHash = await hashText(csvText);

                if (cacheUsable && cached.hash && cached.hash === newHash) {
                    debugLog('[cache] sin cambios: reutilizando caché (evita re-parsear)');
                    setLoadingState({ pct: 55, stage: 'Sin cambios (usando caché)...', detail: `${cached.rows.length.toLocaleString()} filas` });

                    allData = cached.rows;
                    await processData({ progressFrom: 55, progressTo: 100 });

                    showLoadingUI(false);
                    showDashboardUI(true);
                    updateLastUpdateLabel('Sin cambios (caché)');

                    return;
                }

                // 3) Parse CSV (en worker) + progreso animado
                setLoadingState({ pct: 38, stage: 'Procesando CSV...', detail: '' });
                const stopRamp = startProgressRamp(38, 75, 'Procesando CSV...');
                const rows = await parseCsvToRows(csvText);
                stopRamp();

                debugLog(`[parse] filas válidas: ${rows.length.toLocaleString()}`);

                // 4) Guardar caché (para la próxima carga)
                setLoadingState({ pct: 78, stage: 'Guardando en caché...', detail: `${rows.length.toLocaleString()} filas` });
                await cacheSet({
                    hash: newHash,
                    fetchedAt: Date.now(),
                    rows
                });

                // 5) Pintar dashboard
                allData = rows;
                await processData({ progressFrom: 80, progressTo: 100 });

                showLoadingUI(false);
                showDashboardUI(true);
                updateLastUpdateLabel('Actualizado');

                const t1 = performance.now();
                debugLog(`[done] total ${(t1 - t0).toFixed(0)} ms`);
            } catch (error) {
                // Fallback: si falla red, intentar caché aunque no se haya usado
                const cached = await cacheGet();
                const cacheUsable = cached && Array.isArray(cached.rows) && cached.rows.length >= 0;

                debugError('Error al cargar datos', error);

                if (cacheUsable) {
                    debugWarn('Fallo red. Mostrando caché disponible como fallback.');
                    setLoadingState({ pct: 35, stage: 'Fallo red. Usando caché disponible...', detail: `${cached.rows.length.toLocaleString()} filas` });

                    allData = cached.rows;
                    await processData({ progressFrom: 35, progressTo: 100 });

                    showLoadingUI(false);
                    showDashboardUI(true);
                    updateLastUpdateLabel('Caché (fallback por error de red)');
                } else {
                    showError('Error al cargar datos: ' + (error?.message || error) + '. Verifica que el documento sea público o que el proxy esté disponible.');
                }
            } finally {
                elapsedStop();
                window.__VOICEBOT_LOADING__ = false;
                window.__VOICEBOT_LOADING_REASON__ = null;

                btn.disabled = false;
                btnIcon.className = 'fas fa-sync-alt';
            }
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            const errorDiv = document.getElementById('error');
            errorDiv.style.display = 'block';
            errorDiv.className = 'error';
            errorDiv.innerHTML = `<i class="fas fa-exclamation-triangle"></i><div>${message}</div>`;
        }

        async function processData(progressOpts = {}) {
            const { progressFrom = 0, progressTo = 100 } = progressOpts;

            const setP = (pct, stage, detail = '') => {
                const mapped = progressFrom + (pct / 100) * (progressTo - progressFrom);
                setLoadingState({ pct: Math.min(100, Math.max(0, Math.round(mapped))), stage, detail });
            };

            const nextFrame = () => new Promise(res => requestAnimationFrame(res));

            setP(5, 'Calculando KPIs...', '');
            await nextFrame();

            const viewData = getViewData();
            if (viewData && viewData.length) initColumnMap(viewData[0]);
            currentViewData = viewData;
            const viewTotal = viewData.length;
            debugLog(`[view] filas en rango: ${viewTotal.toLocaleString()} (from=${filterState.from || '∅'} to=${filterState.to || '∅'})`);

            // KPIs básicos
            const totalCalls = viewTotal;
            setText('totalCalls', totalCalls.toLocaleString());

            // Llamadas de hoy (fecha local, no UTC)
            const nowLocal = new Date();
            const todayLocal = new Date(nowLocal.getFullYear(), nowLocal.getMonth(), nowLocal.getDate());
            const todayKey = todayLocal.toISOString().split('T')[0];

            const callsToday = viewData.filter(row => {
                if (!row.date_start) return false;
                const callDate = row.date_start.split('T')[0];
                return callDate === todayKey;
            }).length;

            setText('callsToday', callsToday.toLocaleString());
            document.getElementById('todayDate').textContent = new Date().toLocaleDateString('es-HN', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });

            // Clientes únicos
            const uniqueLeads = new Set(viewData.map(row => row.lead_first_name).filter(Boolean)).size;
            setText('uniqueLeads', uniqueLeads.toLocaleString());

            // Contactados vs No Contactados (reglas definidas arriba)
            const nonContactedCount = viewData.filter(row => isNonContactDisposition(getCurrentDisposition(row))).length;
            const aiServerFails = viewData.filter(row => isAiServerFailDisposition(getCurrentDisposition(row))).length;

            // Respondió = tipificaciones que indican interacción real con el bot (tu lista)
            const respondedCount = viewData.filter(row => isRespondedDisposition(getCurrentDisposition(row))).length;

            // Otros = tipificaciones existentes que no entran en ninguna regla (las dejamos visibles para depuración)
            const otherCount = Math.max(0, totalCalls - nonContactedCount - aiServerFails - respondedCount);

            const respondedPercent = totalCalls > 0 ? ((respondedCount / totalCalls) * 100).toFixed(1) : 0;
            const notContactedPercent = totalCalls > 0 ? ((nonContactedCount / totalCalls) * 100).toFixed(1) : 0;
            const aiServerFailsPercent = totalCalls > 0 ? ((aiServerFails / totalCalls) * 100).toFixed(1) : 0;
            const otherPercent = totalCalls > 0 ? ((otherCount / totalCalls) * 100).toFixed(1) : 0;

            // KPIs
            setText('contacted', respondedCount.toLocaleString());
            setText('contactedPercent', respondedPercent + '%');

            setText('notContacted', nonContactedCount.toLocaleString());
            setText('notContactedPercent', notContactedPercent + '%');

            setText('aiServerFails', aiServerFails.toLocaleString());
            setText('aiServerFailsPercent', aiServerFailsPercent + '%');

            // Si existe el KPI de "Otros", lo llenamos; si no existe, lo ignoramos
            const elOtherCount = document.getElementById('otherCount');
            const elOtherPercent = document.getElementById('otherPercent');
            if (elOtherCount && elOtherPercent) {
                elOtherCount.textContent = otherCount.toLocaleString();
                elOtherPercent.textContent = otherPercent + '%';
            }
            // Intentos promedio
            const callCounts = viewData.map(row => parseInt(row.lead_called_count) || 0).filter(c => c > 0);
            const avgAttempts = callCounts.length > 0 
                ? (callCounts.reduce((a, b) => a + b, 0) / callCounts.length).toFixed(2)
                : 0;
            setText('avgAttempts', avgAttempts);

            // Duración promedio
            const durations = currentViewData.map(row => parseInt(row.total_duration) || 0);
            const avgDuration = durations.length > 0
                ? Math.round(durations.reduce((a, b) => a + b, 0) / durations.length)
                : 0;
            setText('avgDuration', avgDuration + 's');

            // Tasa de éxito (ANSWERED)
            const answered = viewData.filter(row => normDisp(row.call_disposition) === 'ANSWERED').length;
            const successRate = totalCalls > 0 ? ((answered / totalCalls) * 100).toFixed(1) : 0;
            setText('successRate', `${successRate}%`);
            document.getElementById('successTrend').innerHTML = `<i class="fas fa-phone-alt"></i> ${answered} llamadas`;

            // Compromisos de pago (confirma + compromiso_de_pago)
            const paymentCommitments = viewData.filter(row => {
                const disp = getCurrentDisposition(row);
                const dispLower = String(disp || '').toLowerCase().trim();
                return dispLower === 'confirma' || dispLower === 'compromiso_de_pago';
            }).length;
            const paymentCommitmentsPercent = totalCalls > 0 ? ((paymentCommitments / totalCalls) * 100).toFixed(1) : 0;
            setText('paymentCommitments', paymentCommitments.toLocaleString());
            setText('paymentCommitmentsPercent', paymentCommitmentsPercent + '%');

            // Estadísticas adicionales
            const totalDurationSec = durations.reduce((a, b) => a + b, 0);
            const hours = Math.floor(totalDurationSec / 3600);
            const minutes = Math.floor((totalDurationSec % 3600) / 60);
            setText('totalDuration', `${hours}h ${minutes}m`);

            const maxDuration = durations.length ? Math.max(...durations) : 0;
            setText('maxDuration', maxDuration + 's');

            // Tasa de contestación (según tipificaciones que indican que el cliente respondió)
            const respondedByDisposition = viewData.filter(row => isRespondedDisposition(getCurrentDisposition(row))).length;
            const denomContest = Math.max(0, totalCalls - aiServerFails); // excluimos fallas de IA porque no hubo llamada
            const answerRate = denomContest > 0 ? ((respondedByDisposition / denomContest) * 100).toFixed(1) : 0;
            setText('answerRate', answerRate + '%');

            const callsPerLead = uniqueLeads > 0 ? (totalCalls / uniqueLeads).toFixed(2) : 0;
            setText('callsPerLead', callsPerLead);

            setP(35, 'Creando gráficos...', '');
            await nextFrame();

            // Crear gráficos (con pequeñas pausas para mantener fluidez)
            const chartSteps = [
                ['Llamadas por Mes', createMonthlyChart],
                ['Estado de Llamadas', createDispositionChart],
                ['Contactados vs No Contactados', createContactChart],
                ['Tipificaciones Detalladas', createDetailedDispositionChart],
                ['Distribución Duración', createDurationChart],
                ['Distribución Intentos', createAttemptsChart]
            ];

            for (let i = 0; i < chartSteps.length; i++) {
                const [label, fn] = chartSteps[i];
                const pct = 35 + Math.round(((i + 1) / chartSteps.length) * 45); // 35% -> 80%
                setP(pct, `Renderizando: ${label} (${i + 1}/${chartSteps.length})`, '');
                await nextFrame();
                fn();
                await nextFrame();
            }

            setP(88, 'Armando tipificaciones...', '');
            await nextFrame();
            renderAllDispositionsTable(viewData);

            setP(100, 'Listo', '');
        }

        
        function renderAllDispositionsTable(rows) {
            const tbody = document.getElementById('allDispositionsBody');
            if (!tbody) return;

            const total = rows.length || 0;
            const counts = {};
            let noEsUnifiedCount = 0; // Contador para todas las tipificaciones no_es
            
            rows.forEach(r => {
                const raw = getCurrentDisposition(r);
                const d = (raw == null || String(raw).trim() === '') ? '(vacío)' : String(raw).trim();
                
                // Unificar todas las tipificaciones que empiezan con "no_es"
                if (d.toLowerCase().startsWith('no_es')) {
                    noEsUnifiedCount++;
                } else {
                    counts[d] = (counts[d] || 0) + 1;
                }
            });
            
            // Agregar la fila unificada de no_es si hay registros
            if (noEsUnifiedCount > 0) {
                counts['no_es_* (unificado)'] = noEsUnifiedCount;
            }

            const entries = Object.entries(counts)
                .sort((a, b) => b[1] - a[1]);

            tbody.innerHTML = entries.map(([disp, cnt]) => {
                const pct = total > 0 ? ((cnt / total) * 100).toFixed(1) : '0.0';
                const cls = classifyDisposition(disp);
                const badge = cls.includes('NO CONTACTADO') ? 'warning'
                              : cls.includes('FALLA') ? 'danger'
                              : 'success';

                return `
                    <tr>
                        <td><strong>${escapeHtml(disp)}</strong></td>
                        <td>${cnt.toLocaleString()}</td>
                        <td>${pct}%</td>
                        <td><span class="badge badge-${badge}">${escapeHtml(cls)}</span></td>
                    </tr>
                `;
            }).join('');
        }

function getChartColors() {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            return {
                textColor: isDark ? '#f1f5f9' : '#1e293b',
                gridColor: isDark ? '#334155' : '#e2e8f0',
                primary: '#667eea',
                secondary: '#764ba2',
                success: '#10b981',
                danger: '#ef4444',
                warning: '#f59e0b',
                info: '#3b82f6'
            };
        }

        function createMonthlyChart() {
            const monthCounts = {};
            currentViewData.forEach(row => {
                if (!row.date_start) return;
                const date = new Date(row.date_start);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                monthCounts[monthKey] = (monthCounts[monthKey] || 0) + 1;
            });

            const sortedMonths = Object.keys(monthCounts).sort();
            const ctx = document.getElementById('monthlyChart');
            const colors = getChartColors();
            
            if (charts.monthly) charts.monthly.destroy();
            
            charts.monthly = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedMonths.map(m => {
                        const [year, month] = m.split('-');
                        const date = new Date(year, month - 1);
                        return date.toLocaleDateString('es-HN', { year: 'numeric', month: 'long' });
                    }),
                    datasets: [{
                        label: 'Llamadas',
                        data: sortedMonths.map(m => monthCounts[m]),
                        backgroundColor: colors.primary,
                        borderColor: colors.primary,
                        borderWidth: 2,
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: false 
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 8
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { color: colors.textColor },
                            grid: { color: colors.gridColor }
                        },
                        x: {
                            ticks: { color: colors.textColor },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        function createDispositionChart() {
            // Estado de Llamadas = distribución REAL de lead_current_disposition (tal como viene en el Excel)
            const counts = {};
            currentViewData.forEach(row => {
                const disp = dispositionLabelFromCurrent(row); // sin upper, tal cual
                counts[disp] = (counts[disp] || 0) + 1;
            });

            // Ordenar por frecuencia y agrupar "Otros" para no saturar la leyenda
            const entries = Object.entries(counts).sort((a,b) => b[1] - a[1]);
            const TOP_N = 12;
            const top = entries.slice(0, TOP_N);
            const rest = entries.slice(TOP_N);
            const othersCount = rest.reduce((acc, [,v]) => acc + v, 0);
            if (othersCount > 0) top.push(['Otros', othersCount]);

            const labels = top.map(([k]) => k);
            const data = top.map(([,v]) => v);

            const ctx = document.getElementById('dispositionChart');
            const colors = getChartColors();
            if (charts.disposition) charts.disposition.destroy();

            const chartColors = [
                colors.primary,
                colors.secondary,
                colors.warning,
                colors.success,
                colors.danger,
                colors.info
            ];

            charts.disposition = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels,
                    datasets: [{
                        data,
                        backgroundColor: labels.map((_, i) => chartColors[i % chartColors.length]),
                        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim(),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: { color: colors.text, padding: 15 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = data.reduce((a,b)=>a+b,0) || 0;
                                    const value = context.raw || 0;
                                    const pct = total ? ((value/total)*100).toFixed(1) : '0.0';
                                    return `${context.label}: ${value.toLocaleString()} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

function createContactChart() {
            const total = currentViewData.length;

            const nonContacted = currentViewData.filter(r => isNonContactDisposition(getCurrentDisposition(r))).length;
            const aiFails = currentViewData.filter(r => isAiServerFailDisposition(getCurrentDisposition(r))).length;
            const responded = currentViewData.filter(r => isRespondedDisposition(getCurrentDisposition(r))).length;
            const others = Math.max(0, total - nonContacted - aiFails - responded);

            const ctx = document.getElementById('contactChart');
            const colors = getChartColors();
            if (charts.contact) charts.contact.destroy();

            const labels = [
                'Respondió (según tipificaciones)',
                'No contactados (ANSWERMACHINE_AUTO / FAILED_AUTO / CANCEL_AUTO)',
                'Fallas servidor IA (AI_SERVER_START_FAILED)',
                'Otros (sin regla)'
            ];

            const data = [responded, nonContacted, aiFails, others];

            charts.contact = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels,
                    datasets: [{
                        data,
                        backgroundColor: [colors.success, colors.warning, colors.danger, colors.secondary],
                        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim(),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: colors.text, padding: 20 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw || 0;
                                    const pct = total > 0 ? ((value / total) * 100).toFixed(1) : '0.0';
                                    return `${context.label}: ${value.toLocaleString()} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }



        function createDetailedDispositionChart() {
            const dispositions = {};
            currentViewData.forEach(row => {
                const disp = dispositionLabelFromCurrent(row);
                dispositions[disp] = (dispositions[disp] || 0) + 1;
            });

            const ctx = document.getElementById('detailedDispositionChart');
            const colors = getChartColors();
            if (charts.detailedDisposition) charts.detailedDisposition.destroy();

            charts.detailedDisposition = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(dispositions),
                    datasets: [{
                        label: 'Cantidad',
                        data: Object.values(dispositions),
                        backgroundColor: colors.secondary,
                        borderColor: colors.secondary,
                        borderWidth: 2,
                        borderRadius: 8
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 8
                        }
                    },
                    scales: {
                        x: { 
                            beginAtZero: true,
                            ticks: { color: colors.textColor },
                            grid: { color: colors.gridColor }
                        },
                        y: {
                            ticks: { color: colors.textColor },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        function createDurationChart() {
            const durations = currentViewData.map(row => parseInt(row.total_duration) || 0);
            const ranges = {
                '0-10s': 0,
                '11-30s': 0,
                '31-60s': 0,
                '1-2min': 0,
                '2-5min': 0,
                '5+ min': 0
            };

            durations.forEach(d => {
                if (d <= 10) ranges['0-10s']++;
                else if (d <= 30) ranges['11-30s']++;
                else if (d <= 60) ranges['31-60s']++;
                else if (d <= 120) ranges['1-2min']++;
                else if (d <= 300) ranges['2-5min']++;
                else ranges['5+ min']++;
            });

            const ctx = document.getElementById('durationChart');
            const colors = getChartColors();
            if (charts.duration) charts.duration.destroy();

            charts.duration = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(ranges),
                    datasets: [{
                        label: 'Cantidad de llamadas',
                        data: Object.values(ranges),
                        backgroundColor: colors.warning,
                        borderColor: colors.warning,
                        borderWidth: 2,
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 8
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { color: colors.textColor },
                            grid: { color: colors.gridColor }
                        },
                        x: {
                            ticks: { color: colors.textColor },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        function createAttemptsChart() {
            const attempts = {};
            currentViewData.forEach(row => {
                const count = parseInt(row.lead_called_count) || 0;
                attempts[count] = (attempts[count] || 0) + 1;
            });

            const ctx = document.getElementById('attemptsChart');
            const colors = getChartColors();
            if (charts.attempts) charts.attempts.destroy();

            charts.attempts = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Object.keys(attempts).sort((a, b) => a - b).map(a => `${a} ${a == 1 ? 'intento' : 'intentos'}`),
                    datasets: [{
                        label: 'Cantidad de clientes',
                        data: Object.keys(attempts).sort((a, b) => a - b).map(k => attempts[k]),
                        backgroundColor: colors.info,
                        borderColor: colors.info,
                        borderWidth: 2,
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            cornerRadius: 8
                        }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { color: colors.textColor },
                            grid: { color: colors.gridColor }
                        },
                        x: {
                            ticks: { color: colors.textColor },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        

        // -----------------------------
        // UI: filtros y comparativa
        // -----------------------------
        function initFiltersUI() {
            // Aviso si se abre con file:// (origin null)
            if (location.protocol === 'file:') {
                console.warn('[Voicebot] Estás abriendo el HTML con file://. Usa Live Server (http://localhost) o un hosting.');
            }

            const quickSel = document.getElementById('quickRange');
            const btnApply = document.getElementById('applyFilterBtn');
            const btnClear = document.getElementById('clearFilterBtn');
            const btnOpenCmp = document.getElementById('openCompareBtn');
            const btnCloseCmp = document.getElementById('closeCompareBtn');
            const panel = document.getElementById('comparePanel');

            if (quickSel) {
                quickSel.value = filterState.quick || 'all';
                quickSel.addEventListener('change', () => {
                    filterState.quick = quickSel.value;
                    const { from, to } = computeQuickRange(filterState.quick);
                    filterState.from = from;
                    filterState.to = to;
                    setFilterInputs(from, to);
                });
            }

            // defaults: "Todo"
            setFilterInputs(filterState.from, filterState.to);

            const recalc = async (label = 'Filtro aplicado') => {
                if (!allData || !Array.isArray(allData)) return;
                showLoadingUI(true);
                showDashboardUI(true);
                setLoadingState({ pct: 0, stage: 'Aplicando filtro...', detail: '' });
                await processData({ progressFrom: 0, progressTo: 100 });
                showLoadingUI(false);
                updateLastUpdateLabel(label);
            };

            if (btnApply) {
                btnApply.addEventListener('click', async () => {
                    const quick = (quickSel?.value || 'all');
                    filterState.quick = quick;

                    if (quick && quick !== 'all') {
                        const { from, to } = computeQuickRange(quick);
                        filterState.from = from;
                        filterState.to = to;
                        setFilterInputs(from, to);
                    } else {
                        const from = document.getElementById('dateFrom')?.value || null;
                        const to = document.getElementById('dateTo')?.value || null;
                        filterState.from = from || null;
                        filterState.to = to || null;
                    }

                    debugLog(`[filter] aplicado quick=${filterState.quick} from=${filterState.from || '∅'} to=${filterState.to || '∅'}`);
                    await recalc('Filtro aplicado');
                });
            }

            if (btnClear) {
                btnClear.addEventListener('click', async () => {
                    filterState.quick = 'all';
                    filterState.from = null;
                    filterState.to = null;
                    if (quickSel) quickSel.value = 'all';
                    setFilterInputs(null, null);
                    debugLog('[filter] limpiado');
                    await recalc('Filtro limpio');
                });
            }

            if (btnOpenCmp && panel) {
                btnOpenCmp.addEventListener('click', () => {
                    panel.style.display = 'block';
                    // Prefill con rango actual
                    const aFrom = document.getElementById('cmpAFrom');
                    const aTo = document.getElementById('cmpATo');
                    if (aFrom && aTo) {
                        aFrom.value = filterState.from || '';
                        aTo.value = filterState.to || '';
                    }
                });
            }
            if (btnCloseCmp && panel) {
                btnCloseCmp.addEventListener('click', () => {
                    panel.style.display = 'none';
                });
            }

            const runBtn = document.getElementById('runCompareBtn');
            if (runBtn) {
                runBtn.addEventListener('click', () => runCompare());
            }
        }

        function computeMetrics(rows) {
            const total = rows.length;
            const nonContacted = rows.filter(r => isNonContactDisposition(getCurrentDisposition(r))).length;
            const aiFails = rows.filter(r => isAiServerFailDisposition(getCurrentDisposition(r))).length;
            const contacted = Math.max(0, total - nonContacted - aiFails);

            const answered = rows.filter(r => normDisp(r.call_disposition) === 'ANSWERED').length;
            const successRate = total > 0 ? (answered / total) * 100 : 0;

            const durations = rows.map(r => parseInt(r.total_duration) || 0);
            const avgDuration = durations.length ? (durations.reduce((a,b)=>a+b,0) / durations.length) : 0;

            return {
                total,
                contacted,
                nonContacted,
                aiFails,
                answered,
                successRate,
                avgDuration
            };
        }

        function sliceByRange(fromKey, toKey) {
            return allData.filter(r => {
                const k = parseRowDateKey(r);
                return inRange(k, fromKey, toKey);
            });
        }

        async function runCompare() {
            const aFrom = document.getElementById('cmpAFrom')?.value || null;
            const aTo = document.getElementById('cmpATo')?.value || null;
            const bFrom = document.getElementById('cmpBFrom')?.value || null;
            const bTo = document.getElementById('cmpBTo')?.value || null;

            if ((!aFrom && !aTo) || (!bFrom && !bTo)) {
                alert('Completa al menos un "Desde/Hasta" para ambos rangos.');
                return;
            }

            const rowsA = sliceByRange(aFrom, aTo);
            const rowsB = sliceByRange(bFrom, bTo);

            const A = computeMetrics(rowsA);
            const B = computeMetrics(rowsB);

            const compareRows = [
                ['Total llamadas', A.total, B.total],
                ['Contactados', A.contacted, B.contacted],
                ['No contactados (3)', A.nonContacted, B.nonContacted],
                ['Fallas IA', A.aiFails, B.aiFails],
                ['ANSWERED', A.answered, B.answered],
                ['Tasa contestación (ANSWERED/Total)', A.successRate, B.successRate, 'pct'],
                ['Duración promedio (s)', A.avgDuration, B.avgDuration, 'num']
            ];

            const tbody = document.getElementById('compareTableBody');
            if (tbody) {
                tbody.innerHTML = compareRows.map(([k, a, b, type]) => {
                    const delta = (b - a);
                    const deltaPct = (a !== 0) ? (delta / a) * 100 : null;

                    const fmt = (v) => {
                        if (type === 'pct') return `${Number(v).toFixed(1)}%`;
                        if (type === 'num') return `${Number(v).toFixed(1)}`;
                        return Number(v).toLocaleString();
                    };

                    const fmtDelta = (v) => {
                        if (type === 'pct') return `${Number(v).toFixed(1)}%`;
                        if (type === 'num') return `${Number(v).toFixed(1)}`;
                        return Number(v).toLocaleString();
                    };

                    const pctTxt = deltaPct === null ? '—' : `${deltaPct.toFixed(1)}%`;

                    return `
                        <tr>
                            <td><strong>${escapeHtml(k)}</strong></td>
                            <td>${fmt(a)}</td>
                            <td>${fmt(b)}</td>
                            <td>${fmtDelta(delta)}</td>
                            <td>${pctTxt}</td>
                        </tr>
                    `;
                }).join('');
            }

            // Chart
            const ctx = document.getElementById('compareChart');
            const colors = getChartColors();
            if (ctx) {
                if (charts.compare) charts.compare.destroy();
                charts.compare = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Total', 'Contactados', 'No contactados (3)', 'Fallas IA', 'ANSWERED'],
                        datasets: [
                            { label: 'Rango A', data: [A.total, A.contacted, A.nonContacted, A.aiFails, A.answered] },
                            { label: 'Rango B', data: [B.total, B.contacted, B.nonContacted, B.aiFails, B.answered] }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'bottom', labels: { color: colors.textColor } }
                        },
                        scales: {
                            x: { ticks: { color: colors.textColor }, grid: { color: colors.gridColor } },
                            y: { ticks: { color: colors.textColor }, grid: { color: colors.gridColor } }
                        }
                    }
                });
            }

            const res = document.getElementById('compareResults');
            if (res) res.style.display = 'block';

            debugLog(`[compare] A(${aFrom || '∅'}..${aTo || '∅'}) filas=${rowsA.length} | B(${bFrom || '∅'}..${bTo || '∅'}) filas=${rowsB.length}`);
        }

// Inicialización
        loadTheme();
        initFiltersUI();
        loadData({ cacheFirst: true, backgroundRefresh: true, reason: 'init' });

        // Auto-refresh cada 5 minutos
        setInterval(() => loadData({ cacheFirst: true, backgroundRefresh: true, reason: 'auto' }), 300000);
    </script>
</body>
</html>
